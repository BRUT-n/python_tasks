def smallestEvenMultiple(n: int) -> int:
    '''
    Этот код находит наименьшее четное кратное числа n
    '''
    return n + n % 2 * n

print(smallestEvenMultiple(5)) #10
print(smallestEvenMultiple(4)) # 4
# # написать с помощью побитовых операций


# matching_brackets решить рекурсивно
# pig latin понял не до конца

# через неделю на литкод, стирать решение https://leetcode.com/problems/buddy-strings/ и решать

'''
# оценка сложности алгоритмов база
Big O - верхняя оценка сложности алгоритма
О(1) - константная сложность, не зависит от входных данных. Выполняется за фиксированное время.
О(n) - линейная сложность, зависит напрямую от входных данных (они все зависят)
О(n**2) - квадратичная сложность (вложенные циклы)
O(log n) - логорифмическая, где входные данные разбиваются и выполняются действия с частью данных (как бинарны поиск)
O(n!) - (1*2*3...n) факториальная, где необходимо провести все возможные решения задачи для получения результата. NP-полные задачи.
ЭКСПОНЕНЦИАЛЬНАЯ
ЛИНЕЙНО-ЛОГОРИФМИЧЕСКАЯ
# оценка сложности по типам данных python
# оценить сложность алгоритмов своих задач
сложность по памяти алгоритма
'''

# https://leetcode.com/problems/single-number/description/ все элементы дубрлированы кроме одно, надо его вывести
# написать без словаря линейной сложностью 
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums_dict = {}
        for num in nums:
            nums_dict.setdefault(num, 0)
            nums_dict[num] += 1
        for key, value in nums_dict.items():
            if value == 1:
                return key

